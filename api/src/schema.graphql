type Recipe @isAuthenticated {
	id: ID!
	name: String
	createdOn: String
	preparationTime: Int
	skillLevel: String
	cookingTime: Int
	description: String
	friendlyUrl: String
	ratings: Int
	nutritionInfo: String
	cusine: String
	ingredients: [String]
		@cypher(
			statement: "MATCH (this)-[:CONTAINS_INGREDIENT]->(i:Ingredient) RETURN collect(i.name)"
		)
		@relation(name: "CONTAINS_INGREDIENT", direction: "OUT")
	dietType: [String]
		@cypher(
			statement: "MATCH (this)-[:DIET_TYPE]->(d:DietType) RETURN collect(d.name)"
		)
		@relation(name: "DIET_TYPE", direction: "OUT")
	keyword: [String]
		@cypher(
			statement: "MATCH (this)-[:KEYWORD]->(k:Keyword) RETURN collect(k.name)"
		)
		@relation(name: "KEYWORD", direction: "OUT")

	collections: [Collection] @relation(name: "RECIPE_ADDED_TO", direction: "OUT")
}

type recipeMapTuple {
	key: String
	value: String
}

type Ingredient {
	id: ID!
	name: String
	friendlyUrl: String
	recipes: [Recipe] @relation(name: "CONTAINS_INGREDIENT", direction: "IN")
}

type Keyword {
	id: ID!
	friendlyUrl: String
	name: String
	recipes: [Recipe] @relation(name: "KEYWORD", direction: "IN")
}

type DietType {
	id: ID!
	friendlyUrl: String
	name: String
	recipes: [Recipe] @relation(name: "DIET_TYPE", direction: "IN")
}

type Collection {
	id: ID!
	name: String
	friendlyUrl: String
	createdOn: String
	user: [User] @relation(name: "COLLECTION_CREATED", direction: "IN")
	recipes: [Recipe] @relation(name: "RECIPE_ADDED_TO", direction: "IN")
}

type User {
	id: ID!
	name: String
	createdOn: String!
	avatarPath: String
	friendlyUrl: String!
	email: String!
	password: String!
	recipes: [Recipe] @relation(name: "ADDED_RECIPE", direction: "OUT")
	collections: [Collection]
		@relation(name: "COLLECTION_CREATED", direction: "OUT")
}

enum Role {
	reader
	user
	admin
}

input CreateRecipeInput {
	id: ID!
	name: String
	description: String
	preparationTime: Int
	skillLevel: String
	cookingTime: Int
	ingredients: [String]
	friendlyUrl: String
	userId: String
	createdOn: String
}

input CreateCollectionInput {
	id: ID!
	name: String!
	friendlyUrl: String!
	userId: String!
	createdOn: String!
}

input AddRecipeToCollection {
	userId: ID!
	collectionId: ID!
	recipeId: ID!
	createdOn: String!
}

input RegisterUserInput {
	id: String!
	email: String!
	name: String!
	createdOn: String!
	friendlyUrl: String!
	password: String!
	defaultCollectionId: String!
}

type Query {
	recipeByName(substring: String): [Recipe]
		@cypher(
			statement: "MATCH (r:Recipe) WHERE r.name CONTAINS $substring RETURN r"
		)

	recipeBySkillLevel(level: String): [Recipe]
		@cypher(statement: "MATCH (r:Recipe) WHERE r.skillLevel = $level RETURN r")

	recipeByPrearationTime(preparationTime: Int): [Recipe]
		@cypher(
			statement: "MATCH (r:Recipe) WHERE r.preparationTime = $preparationTime RETURN r"
		)

	recipeByPrearationTimeGraterThan(preparationTime: Int): [Recipe]
		@cypher(
			statement: "MATCH (r:Recipe) WHERE r.preparationTime >= $preparationTime RETURN r"
		)

	recipeList(
		ingredients: [String]
		allergens: [String]
		skip: Int
		limit: Int
	): [Recipe]
		@cypher(
			statement: """
			MATCH (r:Recipe)
			WHERE all(i in $ingredients WHERE exists((r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: i})))
			AND none(i in $allergens WHERE exists((r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: i})))
			RETURN r
			ORDER BY r.ratings desc
			SKIP $skip
			limit $limit
			"""
		)

	collectionsByUser(userId: String): [Collection]
		@cypher(
			statement: """
			MATCH (c:Collection)<-[r:COLLECTION_CREATED]-(u:User{id: $userId})
				return c
				order by c.createdOn desc
			"""
		)
}

type Mutation {
	createRecipe(input: CreateRecipeInput): Recipe
		@cypher(
			statement: """
			CREATE (r:Recipe{id: $input.id, name: $input.name, description: $input.description, preparationTime: $input.preparationTime,
											 skillLevel: $input.skillLevel, cookingTime: $input.cookingTime, friendlyUrl: $input.friendlyUrl, createdOn: $input.createdOn})
			FOREACH (item in $input.ingredients |
				MERGE (i:Ingredient{name:item})
				CREATE (r)-[rel:CONTAINS_INGREDIENT]->(i)
			)
			WITH r
			MATCH (u:User{id:$input.userId})
			CREATE (u)-[rel:ADDED_RECIPE{createdOn: $input.createdOn}]->(r)
			RETURN r
			"""
		)

	createCollection(input: CreateCollectionInput): Collection
		@cypher(
			statement: """
			CREATE (c:Collection{id:$input.id, name:$input.name, friendlyUrl:$input.friendlyUrl, createdOn:$input.createdOn})
			  WITH c
			  MATCH (u:User{id:$input.userId})
			  CREATE (u)-[rel:COLLECTION_CREATED]->(c)
			  RETURN  c
			"""
		)

	addRecipeToACollection(input: AddRecipeToCollection): Collection
		@cypher(
			statement: """
			MATCH (r:Recipe{id:$input.recipeId})
			WITH r
			MATCH (c:Collection{id:$input.collectionId})
			CREATE (r)-[rel:RECIPE_ADDED_TO{userId:$input.userId, createdOn:$input.createdOn}]->(c)
			return c
			"""
		)

	removeRecipeFromCollection(input: AddRecipeToCollection): Collection
		@cypher(
			statement: """
			MATCH (r:Recipe{id:$input.recipeId})-[rel:RECIPE_ADDED_TO]->(c:Collection{id:$input.collectionId})
			DELETE rel
			RETURN c
			"""
		)

	loginUser(email: String, password: String): String
		@cypher(
			statement: """
			MATCH (u:User{email:$email})
			return u
			"""
		)

	registerUser(input: RegisterUserInput): String
		@cypher(
			statement: """
			CREATE (c:Collection{id:$input.defaultCollectionId, name:\"Want to cook\", friendlyUrl:\"want-to-cook\", createdOn:$input.createdOn})
			WITH c
			CREATE (u:User {id:$input.id, email:$input.email, name: $input.name, createdOn:$input.createdOn, friendlyUrl:$input.friendlyUrl, password:$input.password})
			WITH u, c
			CREATE (u)-[rel:COLLECTION_CREATED]->(c)
			return u.name
			"""
		)
}
